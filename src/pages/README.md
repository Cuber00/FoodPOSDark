# /pages

Это сердце нашего приложения.
Здесь определены все различные функции / экраны / страницы
Каждый экран состоит из “index.js ” файл, который экспортирует контейнер экрана в качестве модуля по умолчанию, который делает экран доступным в качестве функционального компонента.
Каждая страница будет иметь раздел “компоненты”. Здесь будут содержаться все компоненты, которые требуются только для этой страницы.
Как правило, если модуль (утилита, компонент и т.д.) Используется только внутри другого модуля, то я хочу, чтобы он был вложен в структуру каталогов, как показано выше.
Домашняя страница состоит из компонентов “Аутентификация“, ”Панель мониторинга“ и ”Выбор языка", которые вложены внутри.
“CardLayout.js ” является компонентом, специфичным для макета, и используется только в домашних условиях.

# Шаблон дизайна:

Выбор шаблона проектирования является самостоятельным решением и не должен влиять на производительность приложения. Мы реализуем “Шаблон представления контейнера” в этом приложении. Одним из других известных шаблонов проектирования является “Атомарный шаблон”.

Шаблон контейнерной и презентационной компоненты(умной и тупой):
(ссылка: https://reactpatterns.com/&https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0 )

Шаблон реплизации контейнерной компоненты(умная) - это наиболее эффективный и широко используемый шаблон построения объектов в среде react.
Контейнерная компонента: является точкой входа в функцию/Экран. Обязанности контейнерного компонента заключаются в следующем:
✓ выборка данных
✓ интеграция redux
✓ обработка побочных эффектов, интенсивные вычисления или отображение данных
✓ Наконец, передайте необходимый реквизит на просмотр.

Презентационная компонента(тупая): должен содержать только презентационную часть.
✓ Вся логика пользовательского интерфейса / презентации будет находиться здесь.
✓ Другие сложные элементы могут быть разбиты на отдельные компоненты для простоты обслуживания.
✓ Презентационные компоненты используют реквизит, визуализацию и контекст.
✓ Презентационные компоненты получают данные и обратные вызовы только из реквизитов, которые могут быть предоставлены его контейнерным или родительским компонентом.

PropTypes: Очень хорошей практикой является объявление PropTypes для всех компонентов, которые ожидают props от своих родителей. Это позволяет проверять типы, доступность свойств и размещать все необходимые свойства с их типами данных в одном месте.
